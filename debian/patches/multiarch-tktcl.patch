From 21cea042145b8a32b8a481d3e48a6eba749a16d5 Mon Sep 17 00:00:00 2001
From: Julian Taylor <jtaylor@ubuntu.com>
Date: Thu, 8 Oct 2015 09:47:15 -0700
Subject: adapt setup to find multiarched tk/tcl

Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/matplotlib/+bug/752647
Forwarded: no, only if we upstream multiarchification

Patch-Name: multiarch-tktcl.patch
---
 setupext.py | 160 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 160 insertions(+)

diff --git a/setupext.py b/setupext.py
index fc9ff3e..9bb626d 100755
--- a/setupext.py
+++ b/setupext.py
@@ -1318,6 +1318,162 @@ class BackendTkAgg(OptionalBackendPackage):
         LibAgg().add_flags(ext, add_sources=False)
         return ext
 
+    def query_tcltk(self):
+        """
+        Tries to open a Tk window in order to query the Tk object
+        about its library paths.  This should never be called more
+        than once by the same process, as Tk intricacies may cause the
+        Python interpreter to hang. The function also has a workaround
+        if no X server is running (useful for autobuild systems).
+        """
+        # Use cached values if they exist, which ensures this function
+        # only executes once
+        if self.tcl_tk_cache is not None:
+            return self.tcl_tk_cache
+
+        # By this point, we already know that Tkinter imports correctly
+        if PY3:
+            import tkinter as Tkinter
+        else:
+            import Tkinter
+        tcl_lib_dir = ''
+        tk_lib_dir = ''
+        # First try to open a Tk window (requires a running X server)
+        try:
+            tk = Tkinter.Tk()
+        except Tkinter.TclError:
+            # Next, start Tcl interpreter without opening a Tk window
+            # (no need for X server) This feature is available in
+            # python version 2.4 and up
+            try:
+                tcl = Tkinter.Tcl()
+            except AttributeError:    # Python version not high enough
+                pass
+            except Tkinter.TclError:  # Something went wrong while opening Tcl
+                pass
+            else:
+                tcl_lib_dir = str(tcl.getvar('tcl_library'))
+                # Guess Tk location based on Tcl location
+                (head, tail) = os.path.split(tcl_lib_dir)
+                tail = tail.replace('Tcl', 'Tk').replace('tcl', 'tk')
+                tk_lib_dir = os.path.join(head, tail)
+                if not os.path.exists(tk_lib_dir):
+                    tk_lib_dir = tcl_lib_dir.replace(
+                        'Tcl', 'Tk').replace('tcl', 'tk')
+        else:
+            # Obtain Tcl and Tk locations from Tk widget
+            tk.withdraw()
+            tcl_lib_dir = str(tk.getvar('tcl_library'))
+            tk_lib_dir = str(tk.getvar('tk_library'))
+            tk.destroy()
+
+        # Save directories and version string to cache
+        self.tcl_tk_cache = tcl_lib_dir, tk_lib_dir, str(Tkinter.TkVersion)[:3]
+        return self.tcl_tk_cache
+
+    def parse_tcl_config(self, tcl_lib_dir, tk_lib_dir):
+        try:
+            if PY3:
+                import tkinter as Tkinter
+            else:
+                import Tkinter
+        except ImportError:
+            return None
+
+        from distutils import sysconfig
+        tcl_poss = [tcl_lib_dir,
+                    os.path.normpath(os.path.join(tcl_lib_dir, '..')),
+                    "/usr/lib/tcl" + str(Tkinter.TclVersion),
+                    "/usr/lib/%s/tcl%s" % (sysconfig.get_config_var('MULTIARCH'), Tkinter.TclVersion),
+                    "/usr/lib"]
+        tk_poss = [tk_lib_dir,
+                    os.path.normpath(os.path.join(tk_lib_dir, '..')),
+                   "/usr/lib/tk" + str(Tkinter.TkVersion),
+                   "/usr/lib/%s/tk%s" % (sysconfig.get_config_var('MULTIARCH'), Tkinter.TkVersion),
+                   "/usr/lib"]
+        for ptcl, ptk in zip(tcl_poss, tk_poss):
+            tcl_config = os.path.join(ptcl, "tclConfig.sh")
+            tk_config = os.path.join(ptk, "tkConfig.sh")
+            if (os.path.exists(tcl_config) and os.path.exists(tk_config)):
+                break
+        if not (os.path.exists(tcl_config) and os.path.exists(tk_config)):
+            return None
+
+        def get_var(file, varname):
+            p = subprocess.Popen(
+                '. %s ; eval echo ${%s}' % (file, varname),
+                shell=True,
+                executable="/bin/sh",
+                stdout=subprocess.PIPE)
+            result = p.communicate()[0]
+            return result.decode('ascii')
+
+        tcl_lib_dir = get_var(
+            tcl_config, 'TCL_LIB_SPEC').split()[0][2:].strip()
+        tcl_inc_dir = get_var(
+            tcl_config, 'TCL_INCLUDE_SPEC')[2:].strip()
+        tcl_lib = get_var(tcl_config, 'TCL_LIB_FLAG')[2:].strip()
+
+        tk_lib_dir = get_var(tk_config, 'TK_LIB_SPEC').split()[0][2:].strip()
+        tk_inc_dir = get_var(tk_config, 'TK_INCLUDE_SPEC').strip()
+        if tk_inc_dir == '':
+            tk_inc_dir = tcl_inc_dir
+        else:
+            tk_inc_dir = tk_inc_dir[2:]
+        tk_lib = get_var(tk_config, 'TK_LIB_FLAG')[2:].strip()
+
+        if not os.path.exists(os.path.join(tk_inc_dir, 'tk.h')):
+            return None
+
+        return (tcl_lib_dir, tcl_inc_dir, tcl_lib,
+                tk_lib_dir, tk_inc_dir, tk_lib)
+
+    def guess_tcl_config(self, tcl_lib_dir, tk_lib_dir, tk_ver):
+        if not (os.path.exists(tcl_lib_dir) and os.path.exists(tk_lib_dir)):
+            return None
+
+        tcl_lib = os.path.normpath(os.path.join(tcl_lib_dir, '../'))
+        tk_lib = os.path.normpath(os.path.join(tk_lib_dir, '../'))
+
+        tcl_inc = os.path.normpath(
+            os.path.join(tcl_lib_dir,
+                         '../../include/tcl' + tk_ver))
+        if not os.path.exists(tcl_inc):
+            tcl_inc = os.path.normpath(
+                os.path.join(tcl_lib_dir,
+                             '../../include'))
+
+        tk_inc = os.path.normpath(os.path.join(
+            tk_lib_dir,
+            '../../include/tk' + tk_ver))
+        if not os.path.exists(tk_inc):
+            tk_inc = os.path.normpath(os.path.join(
+                tk_lib_dir,
+                '../../include'))
+
+        if not os.path.exists(os.path.join(tk_inc, 'tk.h')):
+            tk_inc = tcl_inc
+
+        if not os.path.exists(tcl_inc):
+            # this is a hack for suse linux, which is broken
+            if (sys.platform.startswith('linux') and
+                os.path.exists('/usr/include/tcl.h') and
+                os.path.exists('/usr/include/tk.h')):
+                tcl_inc = '/usr/include'
+                tk_inc = '/usr/include'
+
+        if not os.path.exists(os.path.join(tk_inc, 'tk.h')):
+            return None
+
+        return tcl_lib, tcl_inc, 'tcl' + tk_ver, tk_lib, tk_inc, 'tk' + tk_ver
+
+    def hardcoded_tcl_config(self):
+        tcl_inc = "/usr/local/include"
+        tk_inc = "/usr/local/include"
+        tcl_lib = "/usr/local/lib"
+        tk_lib = "/usr/local/lib"
+        return tcl_lib, tcl_inc, 'tcl', tk_lib, tk_inc, 'tk'
+
     def add_flags(self, ext):
         ext.include_dirs.extend(['src'])
         if sys.platform == 'win32':
@@ -1484,6 +1640,10 @@ class BackendGtk3Agg(OptionalBackendPackage):
         if 'TRAVIS' in os.environ:
             raise CheckFailed("Can't build with Travis")
 
+        # yoh: Builds of Debian packages often lead to a dead-lock here
+        #      As a workaround forcing build manually without a check
+        BackendAgg.force = True
+        return "ok"
         # This check needs to be performed out-of-process, because
         # importing gi and then importing regular old pygtk afterward
         # segfaults the interpreter.
